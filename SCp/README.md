#Scp example program
Радиус взвешенного ориентированного графа.

## Как поставить пример

Для начала, необходимо поставить остис версии SCp-stable(на момент написания работает только на данной ветке). 
Скачать его можно [тут](https://github.com/ostis-apps/ostis-example-app) или при помощи команды 
< git clone https://github.com/ostis-apps/ostis-example-app.git -b scp_stable> 

Сам пример нужно скачать в папку kb, до этого удалив из этой папки ui_menu:

<git clone https://github.com/pilipeikoko/SCp_radius.git>

Далее, в папке radius,  есть папка menu. Тем есть файл ui_menu_run_scp_program.scs, в котором первая исполняемая роль - scp процесс, запускаемый первым(тут это my_proc).

При запуске остиса сверху появится кнопка, запуск scp-программы. По нажатию этой кнопки начинается выполнение программы, за этим мы можем наблюдать в консле с sctp.

## Как перевести sc-машину в Relesase mode

Дефолтное состояние sc-машины - Debug. При Debug моде, в консоле с sctp будут выводится все исполняемые операторы, что вполне удобно при отладке, однако при показе работы преподавателю, нужно сделать всё красиво.
Переходим в папку sc-machine, открываем файл CMakeLists, находим строку
<set(CMAKE_BUILD_TYPE Debug)>
Меняем Debug на Relesase.
Заходим в папку scripts(ту, которая находится в папке sc-machine)
Запускаем в консоле ./make_all.sh
После выполнения этих пунктов, sc-машина будет переведена в Relesase mode. 

## Кратко про SCp

Каждая SCp программа содержит операторы и параметры. Операторы - аналог всеми известных функций. Первый оператор, усполняемый в данной программе должен быть обозначен rrel_init.
Для перехода к последующим операторам, используется 
<nrel_goto:(название_слудующего_оператора)>

В языке SCp есть 2 типа операнда - rrel_scp_var(переменная) и rrel_scp_const(константа). Константы используеются для нахождения какого-лиюо sc-элемента в sc-памяти по его системному идентификатору либо при выводе константных значений(те значения, которые помещаются в [ ]).
В остальных случаях используются переменные. Будьту внимательны! При использовании не того типа операнда, SCp программы будет работать некорректно либо не будет работать вообще.

Существует 2 типа значения значения операнда - rrel_fixed(переменная с фиксированным значением) и rrel_assign(переменная со свободным значением). rrel_fixed используется в случаях, когда значение переменной уже известно. rrel_assign использвуется в тех случаях, когда значение нам не известно.

В каждом операторе есть <-, которая обозначает что данный оператор выполняет
И для каждого из таких системных обзначений, есть определённое количество операндов- то, что мы обозначаем rrel1 rrel2 и тд
Например, при FindElStr3, булет 3 таких роли + nrel_goto(или nrel_then при нахождении и nrel_else при ненахождении)

Каждая из конструкий поиска элементов на 3 и на 5 соответсвует итераторам на 3 и на 5(как и на с++ с использованием sc-memory).

При вызове подпрограммы, указываем системное слово <-call
Первой ролью будет название вызываемой программы, второй ролью передаваемые параметры в эту программу(принимаемые параметры могут быть in и out, in должны передаваться как fixed, out как assign)
Третьей ролью при вызове подпрограммы будет переменная сигнализатор
После вызова подпрограммы, следующая вызывается функция обязательно должна быть с системным словом <-waitReturn. Тут и нужен сигнализатор, она сигнализирует, когда вызванная программа завершится

## Про алгоритм

Здесь используется обход в глубину. На данном этапе формируются все возможные дуги графа. Обход в глубину проводится с каждой вершины графа. Как так в SCp не как таковой рекурсии, чтобы запомнить вершину, из которой мы пришли в данну, используется неролевое отношение nrel_father. 
Также к каждой вершине присодиняется можноство инцидентых ей вершин при помощи неролевого отношения nrel_incdidental_vertexes. При возврщению к отцу, данное множество восстанавливается в исходное состояние для корректной дальнейшей работы программы.
Для предотвращения цикличности имеется множество посещенных вершин(всё более подробно отображено комметариями в коде).

Далее находим эксцентриситет каждой вершины, из которых выбираем минимальный, это и будет радиусом графа.




